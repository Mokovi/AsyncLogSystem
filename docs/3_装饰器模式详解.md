# AsyncLogSystem 装饰器模式详解

## 1. 装饰器模式概述

### 1.1 什么是装饰器模式

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许我们在不改变对象结构的情况下，动态地给对象添加新的功能。在日志系统中，装饰器用于在日志消息输出之前对其进行增强或修改。

### 1.2 装饰器模式的核心思想

- **包装**: 装饰器包装了另一个对象（被装饰的对象）
- **透明**: 装饰器实现了与被装饰对象相同的接口
- **组合**: 可以组合多个装饰器，形成装饰器链
- **扩展**: 在不修改现有代码的情况下扩展功能

## 2. 装饰器在日志系统中的作用

### 2.1 装饰器的本质

**重要理解**: 装饰器本身也是一个Output，它实现了`ILogOutput`接口，但它**包装了另一个Output**，在调用被包装的Output之前或之后添加额外的功能。

```cpp
// 装饰器继承自ILogOutput，所以它本身就是一个Output
class LogDecorator : public ILogOutput {
protected:
    std::unique_ptr<ILogOutput> wrapped;  // 被包装的Output
    
public:
    void write(const LogMessage& msg) override {
        // 1. 先对消息进行装饰（添加时间戳、颜色等）
        LogMessage decoratedMsg = decorateMessage(msg);
        
        // 2. 然后调用被包装的Output的write方法
        wrapped->write(decoratedMsg);
    }
};
```

### 2.2 装饰器的工作流程

```
原始日志消息 → 装饰器1 → 装饰器2 → ... → 最终输出
     ↓              ↓         ↓              ↓
   "Hello"    → 添加时间戳 → 添加颜色 → 输出到控制台
     ↓              ↓         ↓              ↓
   "Hello"    → "[2025-08-25 11:30:00] Hello" → "\033[32m[2025-08-25 11:30:00] Hello\033[0m" → 显示
```

## 3. 装饰器的具体实现

### 3.1 时间戳装饰器 (TimestampDecorator)

```cpp
class TimestampDecorator : public LogDecorator {
private:
    std::string format_;
    
public:
    TimestampDecorator(std::unique_ptr<ILogOutput> output, 
                      const std::string& format = "%Y-%m-%d %H:%M:%S")
        : LogDecorator(std::move(output)), format_(format) {}
    
    void write(const LogMessage& msg) override {
        // 创建增强的消息
        LogMessage enhancedMsg = msg;
        
        // 添加时间戳到消息前面
        std::string timestamp = getCurrentTimestamp();
        enhancedMsg.message = "[" + timestamp + "] " + msg.message;
        
        // 委托给被包装的输出
        wrapped_->write(enhancedMsg);
    }
};
```

**作用**: 在每条日志消息前添加时间戳信息

### 3.2 颜色装饰器 (ColorDecorator)

```cpp
class ColorDecorator : public LogDecorator {
public:
    explicit ColorDecorator(std::unique_ptr<ILogOutput> output)
        : LogDecorator(std::move(output)) {}
    
    void write(const LogMessage& msg) override {
        // 创建增强的消息
        LogMessage enhancedMsg = msg;
        
        // 根据日志级别添加颜色代码
        std::string colorCode = getColorCode(msg.level);
        std::string resetCode = getResetCode();
        enhancedMsg.message = colorCode + msg.message + resetCode;
        
        // 委托给被包装的输出
        wrapped_->write(enhancedMsg);
    }
};
```

**作用**: 根据日志级别为消息添加颜色，提高可读性

### 3.3 过滤装饰器 (FilterDecorator)

```cpp
class FilterDecorator : public LogDecorator {
private:
    std::function<bool(const LogMessage&)> filter_;
    
public:
    FilterDecorator(std::unique_ptr<ILogOutput> output,
                   std::function<bool(const LogMessage&)> filter)
        : LogDecorator(std::move(output)), filter_(filter) {}
    
    void write(const LogMessage& msg) override {
        // 检查消息是否通过过滤条件
        if (filter_ && filter_(msg)) {
            // 通过过滤，委托给被包装的输出
            wrapped_->write(msg);
        }
        // 不通过过滤的消息被丢弃
    }
};
```

**作用**: 根据自定义条件过滤日志消息

## 4. 装饰器的组合使用

### 4.1 装饰器链的构建

```cpp
// 从最内层开始构建装饰器链
std::unique_ptr<ILogOutput> output = std::make_unique<ConsoleOutput>();

// 添加时间戳装饰器
output = std::make_unique<TimestampDecorator>(std::move(output));

// 添加颜色装饰器
output = std::make_unique<ColorDecorator>(std::move(output));

// 添加过滤装饰器
output = std::make_unique<FilterDecorator>(std::move(output), 
    [](const LogMessage& msg) -> bool {
        return static_cast<int>(msg.level) >= static_cast<int>(LogLevel::INFO);
    });

// 现在output是一个完整的装饰器链
```

### 4.2 装饰器链的执行顺序

```
消息流向: 过滤装饰器 → 颜色装饰器 → 时间戳装饰器 → 控制台输出
执行顺序: 过滤检查 → 添加颜色 → 添加时间戳 → 实际输出
```

### 4.3 动态装饰器组合

```cpp
std::unique_ptr<ILogOutput> createDecoratedOutput(const LogConfig& config) {
    std::unique_ptr<ILogOutput> output = std::make_unique<ConsoleOutput>();
    
    // 根据配置动态添加装饰器
    if (config.enableTimestamp) {
        output = std::make_unique<TimestampDecorator>(std::move(output));
    }
    
    if (config.enableColor) {
        output = std::make_unique<ColorDecorator>(std::move(output));
    }
    
    if (config.enableCompression) {
        output = std::make_unique<CompressionDecorator>(std::move(output));
    }
    
    return output;
}
```

## 5. 装饰器与普通输出的区别

### 5.1 普通输出 (ILogOutput)

```cpp
class ConsoleOutput : public ILogOutput {
public:
    void write(const LogMessage& msg) override {
        // 直接输出到控制台
        std::cout << msg.message << std::endl;
    }
};
```

**特点**:
- 直接输出到目标
- 不修改消息内容
- 功能单一

### 5.2 装饰器输出 (LogDecorator)

```cpp
class TimestampDecorator : public LogDecorator {
public:
    void write(const LogMessage& msg) override {
        // 修改消息内容
        LogMessage enhancedMsg = msg;
        enhancedMsg.message = "[" + getCurrentTimestamp() + "] " + msg.message;
        
        // 委托给被包装的输出
        wrapped_->write(enhancedMsg);
    }
};
```

**特点**:
- 修改消息内容
- 委托给被包装的输出
- 可以组合多个功能

## 6. 装饰器的优势

### 6.1 灵活性

- **动态组合**: 可以根据配置动态组合不同的装饰器
- **功能扩展**: 在不修改现有代码的情况下添加新功能
- **条件启用**: 可以根据需要启用或禁用某些装饰器

### 6.2 可维护性

- **单一职责**: 每个装饰器只负责一个功能
- **易于测试**: 可以单独测试每个装饰器
- **易于扩展**: 添加新的装饰器不需要修改现有代码

### 6.3 性能

- **零拷贝**: 装饰器链中的消息传递是高效的
- **条件执行**: 某些装饰器（如过滤）可以避免不必要的处理
- **内存友好**: 使用智能指针管理内存

## 7. 实际使用示例

### 7.1 基础使用

```cpp
// 创建带时间戳的控制台输出
auto output = std::make_unique<TimestampDecorator>(
    std::make_unique<ConsoleOutput>()
);

// 使用
output->write(LogMessage(LogLevel::INFO, "Hello World"));
// 输出: [2025-08-25 11:30:00] Hello World
```

### 7.2 高级组合

```cpp
// 创建复杂的装饰器链
auto output = std::make_unique<FilterDecorator>(
    std::make_unique<ColorDecorator>(
        std::make_unique<TimestampDecorator>(
            std::make_unique<FileOutput>("app.log")
        )
    ),
    [](const LogMessage& msg) -> bool {
        return msg.level != LogLevel::DEBUG;  // 过滤掉DEBUG级别的日志
    }
);

// 使用
output->write(LogMessage(LogLevel::INFO, "Important message"));
// 结果: 带颜色的时间戳消息被写入文件，DEBUG消息被过滤
```

## 8. 总结

装饰器模式在AsyncLogSystem中扮演着重要角色：

1. **装饰器本身是Output**: 实现了`ILogOutput`接口，可以像普通输出一样使用
2. **装饰器包装Output**: 在调用被包装的输出之前，对消息进行增强
3. **支持链式组合**: 可以组合多个装饰器，形成功能丰富的输出链
4. **动态配置**: 支持根据配置动态组合装饰器
5. **高性能**: 零拷贝设计，高效的装饰器链执行

通过装饰器模式，AsyncLogSystem实现了功能的高度可扩展性，用户可以根据需要组合不同的装饰器，创建满足特定需求的日志输出。
