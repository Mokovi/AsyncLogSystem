# 开发规范

## 1. 代码风格规范

### 1.1 命名规范

#### 1.1.1 类名
- 使用**PascalCase**命名法
- 类名应该是名词，清晰表达类的职责
- 接口类以`I`开头

```cpp
// 正确示例
class LogManager { };
class ILogOutput { };
class FileOutput { };
class TimestampDecorator { };

// 错误示例
class logManager { };
class Log_output { };
class fileoutput { };
```

#### 1.1.2 函数名
- 使用**camelCase**命名法
- 函数名应该是动词或动词短语
- 布尔函数以`is`、`has`、`can`等开头

```cpp
// 正确示例
void write(const LogMessage& msg);
bool isEmpty() const;
void addOutput(std::unique_ptr<ILogOutput> output);
std::string getCurrentTimestamp();

// 错误示例
void Write(const LogMessage& msg);
bool empty() const;
void add_output(std::unique_ptr<ILogOutput> output);
```

#### 1.1.3 变量名
- 使用**camelCase**命名法
- 成员变量以`m_`开头
- 静态成员变量以`s_`开头
- 常量使用**UPPER_SNAKE_CASE**

```cpp
// 正确示例
class LogManager {
private:
    std::string m_filePath;
    static std::mutex s_instanceMutex;
    static const int MAX_QUEUE_SIZE = 10000;
    
public:
    void processMessage(const LogMessage& msg);
};

// 错误示例
class LogManager {
private:
    std::string filepath;
    static std::mutex instanceMutex;
    static const int maxQueueSize = 10000;
};
```

#### 1.1.4 命名空间
- 使用**snake_case**命名法
- 避免过深的嵌套

```cpp
// 正确示例
namespace log_system {
namespace core { }
namespace utils { }
}

// 错误示例
namespace LogSystem {
namespace Core { }
}
```

### 1.2 格式规范

#### 1.2.1 缩进和空格
- 使用4个空格进行缩进，不使用Tab
- 操作符前后加空格
- 逗号后加空格
- 函数参数列表过长时换行对齐

```cpp
// 正确示例
void LogManager::log(LogLevel level,
                     const std::string& message,
                     const std::string& file,
                     int line) {
    if (level >= m_minLevel) {
        auto msg = LogMessage(level, message, file, line);
        m_messageQueue->push(std::move(msg));
    }
}

// 错误示例
void LogManager::log(LogLevel level,const std::string& message,const std::string& file,int line){
if(level>=m_minLevel){
auto msg=LogMessage(level,message,file,line);
m_messageQueue->push(std::move(msg));
}
}
```

#### 1.2.2 大括号风格
- 使用**K&R风格**（开括号不换行）
- 控制语句必须使用大括号，即使只有一条语句

```cpp
// 正确示例
if (condition) {
    doSomething();
}

for (int i = 0; i < count; ++i) {
    processItem(i);
}

// 错误示例
if (condition)
    doSomething();

for (int i = 0; i < count; ++i)
    processItem(i);
```

#### 1.2.3 行长度
- 每行代码不超过120个字符
- 超过时进行适当的换行和缩进

```cpp
// 正确示例
std::unique_ptr<ILogOutput> LogOutputFactory::createOutput(
    const std::string& type,
    const Config& config) {
    
    auto it = s_creators.find(type);
    if (it != s_creators.end()) {
        return it->second(config);
    }
    return nullptr;
}
```

### 1.3 类型规范

#### 1.3.1 类型别名
- 使用`using`而不是`typedef`
- 类型别名使用**snake_case**命名法

```cpp
// 正确示例
using LogMessagePtr = std::unique_ptr<LogMessage>;
using OutputVector = std::vector<std::unique_ptr<ILogOutput>>;
using ConfigMap = std::unordered_map<std::string, std::string>;

// 错误示例
typedef std::unique_ptr<LogMessage> LogMessagePtr;
typedef std::vector<std::unique_ptr<ILogOutput>> OutputVector;
```

#### 1.3.2 智能指针
- 优先使用`std::unique_ptr`
- 需要共享所有权时使用`std::shared_ptr`
- 避免使用裸指针

```cpp
// 正确示例
class LogManager {
private:
    std::unique_ptr<LockFreeQueue<LogMessage>> m_messageQueue;
    std::vector<std::unique_ptr<ILogOutput>> m_outputs;
    
public:
    void addOutput(std::unique_ptr<ILogOutput> output);
};

// 错误示例
class LogManager {
private:
    LockFreeQueue<LogMessage>* m_messageQueue;
    std::vector<ILogOutput*> m_outputs;
    
public:
    void addOutput(ILogOutput* output);
};
```

## 2. 注释规范

### 2.1 文件头注释
每个源文件和头文件都应该包含文件头注释：

```cpp
/**
 * @file log_manager.h
 * @brief 日志管理器类定义
 * @author 作者名
 * @date 创建日期
 * @version 1.0
 * 
 * 该类实现了日志系统的核心管理功能，采用单例模式，
 * 负责协调各个组件的工作。
 */
```

### 2.2 类注释
每个类都应该有详细的注释说明：

```cpp
/**
 * @brief 日志管理器类
 * 
 * 日志管理器是整个日志系统的核心组件，负责：
 * - 管理日志配置
 * - 协调各个输出组件
 * - 提供统一的日志接口
 * - 管理系统的生命周期
 * 
 * 该类采用单例模式，确保全局只有一个实例。
 * 线程安全，支持多线程并发访问。
 * 
 * @example
 * ```cpp
 * auto& logger = LogManager::getInstance();
 * logger.log(LogLevel::INFO, "Hello, World!");
 * ```
 */
class LogManager {
    // ... 类实现
};
```

### 2.3 函数注释
公共接口函数必须有详细的注释：

```cpp
/**
 * @brief 记录日志消息
 * 
 * 将指定级别的日志消息添加到处理队列中，异步处理。
 * 该函数是线程安全的，可以被多个线程同时调用。
 * 
 * @param level 日志级别
 * @param message 日志消息内容
 * @param file 源文件名（可选）
 * @param line 源文件行号（可选）
 * 
 * @note 如果日志级别低于配置的最小级别，消息将被忽略
 * @warning 该函数不会阻塞调用线程
 * 
 * @see LogLevel, LogMessage
 */
void log(LogLevel level,
         const std::string& message,
         const std::string& file = "",
         int line = 0);
```

### 2.4 内联注释
复杂逻辑需要添加内联注释：

```cpp
// 检查队列是否已满，如果满了则等待
while (m_messageQueue->getSize() >= m_maxQueueSize) {
    // 等待消费者处理一些消息
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
    
    // 如果等待时间过长，记录警告
    if (++waitCount > MAX_WAIT_COUNT) {
        // TODO: 考虑实现背压机制
        break;
    }
}
```

## 3. 错误处理规范

### 3.1 异常使用
- 使用异常处理不可恢复的错误
- 异常类应该继承自`std::exception`
- 提供有意义的错误信息

```cpp
/**
 * @brief 日志系统异常类
 */
class LogSystemException : public std::exception {
private:
    std::string m_message;
    
public:
    explicit LogSystemException(const std::string& message)
        : m_message(message) {}
    
    const char* what() const noexcept override {
        return m_message.c_str();
    }
};

// 使用示例
void LogManager::addOutput(std::unique_ptr<ILogOutput> output) {
    if (!output) {
        throw LogSystemException("Output cannot be null");
    }
    
    try {
        m_outputs.push_back(std::move(output));
    } catch (const std::exception& e) {
        throw LogSystemException("Failed to add output: " + std::string(e.what()));
    }
}
```

### 3.2 错误码
- 对于可恢复的错误，使用错误码
- 定义清晰的错误码枚举
- 提供错误码到错误信息的映射

```cpp
/**
 * @brief 操作结果枚举
 */
enum class Result {
    SUCCESS = 0,
    INVALID_PARAMETER = 1,
    FILE_NOT_FOUND = 2,
    PERMISSION_DENIED = 3,
    OUT_OF_MEMORY = 4,
    SYSTEM_ERROR = 5
};

/**
 * @brief 获取错误描述
 */
std::string getErrorDescription(Result result) {
    static const std::unordered_map<Result, std::string> descriptions = {
        {Result::SUCCESS, "操作成功"},
        {Result::INVALID_PARAMETER, "无效参数"},
        {Result::FILE_NOT_FOUND, "文件未找到"},
        {Result::PERMISSION_DENIED, "权限不足"},
        {Result::OUT_OF_MEMORY, "内存不足"},
        {Result::SYSTEM_ERROR, "系统错误"}
    };
    
    auto it = descriptions.find(result);
    return (it != descriptions.end()) ? it->second : "未知错误";
}
```

## 4. 性能规范

### 4.1 内存管理
- 避免频繁的内存分配和释放
- 使用对象池管理频繁创建的对象
- 合理使用移动语义

```cpp
// 正确示例：使用移动语义
void LogManager::processMessage(LogMessage&& msg) {
    // 移动构造，避免拷贝
    auto processedMsg = LogMessage(std::move(msg));
    // ... 处理逻辑
}

// 错误示例：不必要的拷贝
void LogManager::processMessage(const LogMessage& msg) {
    LogMessage processedMsg = msg;  // 不必要的拷贝
    // ... 处理逻辑
}
```

### 4.2 算法优化
- 选择合适的容器和算法
- 避免在循环中进行不必要的计算
- 使用引用避免拷贝

```cpp
// 正确示例
void LogManager::notifyAll(const LogMessage& msg) {
    for (const auto& output : m_outputs) {
        output->write(msg);  // 传递引用
    }
}

// 错误示例
void LogManager::notifyAll(const LogMessage& msg) {
    for (auto output : m_outputs) {  // 不必要的拷贝
        output->write(msg);
    }
}
```

## 5. 测试规范

### 5.1 单元测试
- 每个公共接口都要有对应的单元测试
- 测试覆盖率不低于80%
- 使用Google Test框架

```cpp
// 测试示例
TEST(LogManagerTest, SingletonPattern) {
    auto& instance1 = LogManager::getInstance();
    auto& instance2 = LogManager::getInstance();
    
    EXPECT_EQ(&instance1, &instance2);
}

TEST(LogManagerTest, AddOutput) {
    auto& logger = LogManager::getInstance();
    auto output = std::make_unique<ConsoleOutput>();
    
    EXPECT_NO_THROW(logger.addOutput(std::move(output)));
}
```

### 5.2 集成测试
- 测试组件间的协作
- 测试异常情况下的系统行为
- 测试性能指标

## 6. 文档规范

### 6.1 API文档
- 使用Doxygen生成API文档
- 每个公共接口都有详细的说明
- 提供使用示例

### 6.2 设计文档
- 记录重要的设计决策
- 说明设计模式的选用原因
- 记录性能测试结果

## 7. 版本控制规范

### 7.1 提交信息
- 使用清晰的提交信息
- 遵循约定式提交规范

```bash
# 正确示例
feat: 添加文件输出装饰器支持
fix: 修复内存泄漏问题
docs: 更新API文档
test: 添加单元测试用例
refactor: 重构日志格式化逻辑

# 错误示例
update
fix bug
add feature
```

### 7.2 分支管理
- 主分支：`main`或`master`
- 开发分支：`develop`
- 功能分支：`feature/功能名`
- 修复分支：`hotfix/问题描述`
- 发布分支：`release/版本号`

## 8. 代码审查规范

### 8.1 审查要点
- 代码风格是否符合规范
- 是否有潜在的性能问题
- 错误处理是否完善
- 测试覆盖是否充分
- 文档是否完整

### 8.2 审查流程
1. 开发者提交代码
2. 自动检查（风格检查、编译检查）
3. 代码审查员审查
4. 修改问题后重新审查
5. 合并到目标分支
