# 开发规范

## 1. 代码风格规范

### 1.1 命名规范

#### 1.1.1 类名
- 使用**PascalCase**命名法
- 类名应该是名词，清晰表达类的职责
- 接口类命名约定：
  - 使用`I`前缀（如`ILogOutput`）：便于识别纯虚接口，与C#风格一致
  - 或使用`Interface`后缀（如`LogOutputInterface`）：更明确表达接口性质
- 团队统一使用一种风格，推荐使用`I`前缀

```cpp
// 正确示例（使用I前缀）
class LogManager { };
class ILogOutput { };
class FileOutput { };
class TimestampDecorator { };

// 正确示例（使用Interface后缀）
class LogManager { };
class LogOutputInterface { };
class FileOutput { };
class TimestampDecorator { };

// 错误示例
class logManager { };
class Log_output { };
class fileoutput { };
```

#### 1.1.2 函数名
- 使用**camelCase**命名法
- 函数名应该是动词或动词短语
- 布尔函数以`is`、`has`、`can`等开头

```cpp
// 正确示例
void write(const LogMessage& msg);
bool isEmpty() const;
void addOutput(std::unique_ptr<ILogOutput> output);
std::string getCurrentTimestamp();

// 错误示例
void Write(const LogMessage& msg);
bool empty() const;
void add_output(std::unique_ptr<ILogOutput> output);
```

#### 1.1.3 变量名
- 使用**camelCase**命名法
- 成员变量以`_`结尾
- 常量使用**UPPER_SNAKE_CASE**

```cpp
// 正确示例
class LogManager {
private:
    std::string filePath_;
    static std::mutex instanceMutex_;
    static const int MAX_QUEUE_SIZE = 10000;
    
public:
    void processMessage(const LogMessage& msg);
};

// 错误示例
class LogManager {
private:
    std::string filepath;
    static std::mutex instanceMutex;
    static const int maxQueueSize = 10000;
};
```

#### 1.1.4 文件名
- 使用**camelCase**命名法
- 头文件扩展名约定：
  - 普通头文件：`.h`或`.hpp`（推荐`.hpp`，明确表示C++头文件）
  - 模板实现文件：`.tpp`或`.ipp`（避免ODR问题）
- 源文件使用`.cpp`扩展名
- 测试文件以`test`开头
- 示例文件以`example`或`demo`开头

#### 1.1.5 命名空间
- 使用**snake_case**命名法
- 避免过深的嵌套

```cpp
// 正确示例
namespace log_system {
namespace core { }
namespace utils { }
}

// 错误示例
namespace LogSystem {
namespace Core { }
}
```

### 1.2 格式规范

#### 1.2.1 缩进和空格
- 使用4个空格进行缩进，不使用Tab
- 操作符前后加空格
- 逗号后加空格
- 函数参数列表过长时换行对齐

```cpp
// 正确示例
void LogManager::log(LogLevel level,
                     const std::string& message,
                     const std::string& file,
                     int line) {
    if (level >= minLevel_) {
        auto msg = LogMessage(level, message, file, line);
        messageQueue_->push(std::move(msg));
    }
}

// 错误示例
void LogManager::log(LogLevel level,const std::string& message,const std::string& file,int line){
if(level>=minLevel_){
auto msg=LogMessage(level,message,file,line);
messageQueue_->push(std::move(msg));
}
}
```

#### 1.2.2 大括号风格
- 使用**K&R风格**（开括号不换行）
- 控制语句必须使用大括号，即使只有一条语句

```cpp
// 正确示例
if (condition) {
    doSomething();
}

for (int i = 0; i < count; ++i) {
    processItem(i);
}

// 错误示例
if (condition)
    doSomething();

for (int i = 0; i < count; ++i)
    processItem(i);
```

#### 1.2.3 行长度
- 每行代码不超过120个字符
- 超过时进行适当的换行和缩进

```cpp
// 正确示例
std::unique_ptr<ILogOutput> LogOutputFactory::createOutput(
    const std::string& type,
    const Config& config) {
    
    auto it = s_creators.find(type);
    if (it != s_creators.end()) {
        return it->second(config);
    }
    return nullptr;
}
```

### 1.3 类型规范

#### 1.3.1 类型别名
- 使用`using`而不是`typedef`
- 类型别名使用**PascalCase**命名法（与类名保持一致）

```cpp
// 正确示例
using LogMessagePtr = std::unique_ptr<LogMessage>;
using OutputVector = std::vector<std::unique_ptr<ILogOutput>>;
using ConfigMap = std::unordered_map<std::string, std::string>;

// 错误示例
typedef std::unique_ptr<LogMessage> LogMessagePtr;
typedef std::vector<std::unique_ptr<ILogOutput>> OutputVector;
using log_message_ptr = std::unique_ptr<LogMessage>;  // 不推荐
```

#### 1.3.2 现代C++习惯
- **智能指针使用**：
  - 优先使用`std::unique_ptr`
  - 需要共享所有权时使用`std::shared_ptr`
  - 避免使用裸指针
- **空指针**：使用`nullptr`而非`NULL`或`0`
- **函数重写**：重写虚函数时必须加`override`，必要时加`final`
- **异常安全**：公共API上标注`noexcept`（若不抛异常）
- **常量表达式**：尽量使用`constexpr`/`consteval`

```cpp
// 正确示例
class LogManager {
private:
    std::unique_ptr<LockFreeQueue<LogMessage>> messageQueue_;
    std::vector<std::unique_ptr<ILogOutput>> outputs_;
    
public:
    void addOutput(std::unique_ptr<ILogOutput> output) noexcept;
    virtual ~LogManager() noexcept = default;
    
    // 禁用拷贝构造和赋值
    LogManager(const LogManager&) = delete;
    LogManager& operator=(const LogManager&) = delete;
    
    // 支持移动构造和赋值
    LogManager(LogManager&&) noexcept = default;
    LogManager& operator=(LogManager&&) noexcept = default;
};

// 错误示例
class LogManager {
private:
    LockFreeQueue<LogMessage>* messageQueue_;  // 裸指针
    std::vector<ILogOutput*> outputs_;
    
public:
    void addOutput(ILogOutput* output);  // 裸指针参数
    virtual ~LogManager() { }  // 缺少noexcept
};
```

## 2. 头文件规范

### 2.1 Header Guard
- 推荐使用`#pragma once`（简单且广泛支持）
- 同时提供`#ifndef`作为fallback模式

```cpp
// 推荐方式
#pragma once

// 或者使用传统方式
#ifndef LOG_MANAGER_HPP
#define LOG_MANAGER_HPP

// ... 头文件内容 ...

#endif // LOG_MANAGER_HPP
```

### 2.2 Include顺序和规则
- 严格按照以下顺序包含头文件：
  1. 当前模块头文件
  2. 本项目其他头文件
  3. 第三方库头文件
  4. 标准库头文件
- 采用"包含你所使用的"（Include What You Use）原则
- 每个分组之间用空行分隔

```cpp
// 正确示例
#include "log_manager.hpp"           // 当前模块头

#include "thread_safe_queue.hpp"     // 本项目其他头
#include "async_log_system.hpp"

#include <spdlog/spdlog.h>           // 第三方库头
#include <fmt/format.h>

#include <memory>                    // 标准库头
#include <string>
#include <vector>
#include <unordered_map>

// 错误示例
#include <vector>                    // 标准库头在前
#include "log_manager.hpp"           // 项目头在后
#include <memory>
```

## 3. Doxygen注释规范

### 3.1 文件头注释
每个源文件和头文件都必须包含标准的Doxygen文件头注释：

```cpp
/**
 * @file log_manager.h
 * @brief 日志管理器类定义
 * @author 作者名
 * @date 创建日期
 * @version 1.0
 * @copyright 版权信息（可选）
 * 
 * @details
 * 该类实现了日志系统的核心管理功能，采用单例模式，
 * 负责协调各个组件的工作。提供线程安全的日志记录、
 * 配置管理和输出组件协调功能。
 * 
 * @see LogLevel, LogMessage, ILogOutput
 * @since 1.0.0
 */
```

### 3.2 类注释
每个类都必须有详细的Doxygen注释说明：

```cpp
/**
 * @brief 日志管理器类
 * 
 * @details
 * 日志管理器是整个日志系统的核心组件，负责：
 * - 管理日志配置
 * - 协调各个输出组件
 * - 提供统一的日志接口
 * - 管理系统的生命周期
 * 
 * 该类采用单例模式，确保全局只有一个实例。
 * 线程安全，支持多线程并发访问。
 * 
 * @note 该类是线程安全的，支持多线程并发调用
 * @warning 必须在程序退出前调用shutdown()方法
 * @see LogLevel, LogMessage, ILogOutput
 * @since 1.0.0
 * 
 * @example
 * ```cpp
 * auto& logger = LogManager::getInstance();
 * logger.log(LogLevel::INFO, "Hello, World!");
 * logger.shutdown();
 * ```
 */
class LogManager {
    // ... 类实现
};
```

### 3.3 函数注释
公共接口函数必须有详细的Doxygen注释：

```cpp
/**
 * @brief 记录日志消息
 * 
 * @details
 * 将指定级别的日志消息添加到处理队列中，异步处理。
 * 该函数是线程安全的，可以被多个线程同时调用。
 * 
 * @param[in] level 日志级别
 * @param[in] message 日志消息内容
 * @param[in] file 源文件名（可选，默认为空字符串）
 * @param[in] line 源文件行号（可选，默认为0）
 * 
 * @return void
 * @throws LogSystemException 当消息队列满或系统未初始化时
 * @note 如果日志级别低于配置的最小级别，消息将被忽略
 * @warning 该函数不会阻塞调用线程
 * @pre 系统必须已经初始化
 * @post 消息被添加到处理队列中
 * @see LogLevel, LogMessage
 * @since 1.0.0
 */
void log(LogLevel level,
         const std::string& message,
         const std::string& file = "",
         int line = 0);
```

### 3.4 枚举和常量注释
枚举和常量必须有Doxygen注释：

```cpp
/**
 * @brief 日志级别枚举
 * 
 * @details
 * 定义了系统中支持的所有日志级别，从低到高排列。
 * 只有达到或超过配置的最小级别时，日志才会被记录。
 * 
 * @since 1.0.0
 */
enum class LogLevel {
    TRACE = 0,    ///< 跟踪信息，最详细的日志级别
    DEBUG = 1,    ///< 调试信息，用于开发调试
    INFO = 2,     ///< 一般信息，记录系统运行状态
    WARN = 3,     ///< 警告信息，潜在问题但不影响运行
    ERROR = 4,    ///< 错误信息，系统错误但不致命
    FATAL = 5     ///< 致命错误，系统无法继续运行
};

/**
 * @brief 最大队列大小常量
 * 
 * @details
 * 定义日志消息队列的最大容量，超过此容量时新消息将被丢弃。
 * 
 * @note 此值影响内存使用和性能
 * @since 1.0.0
 */
static constexpr size_t MAX_QUEUE_SIZE = 10000;
```

### 3.5 成员变量注释
重要的成员变量应该有Doxygen注释：

```cpp
class LogManager {
private:
    /**
     * @brief 日志消息队列
     * 
     * @details
     * 存储待处理的日志消息，采用线程安全的队列实现。
     * 支持异步处理，提高日志记录性能。
     * 
     * @note 队列大小受MAX_QUEUE_SIZE限制
     * @since 1.0.0
     */
    std::unique_ptr<ThreadSafeQueue<LogMessage>> messageQueue_;
    
    /**
     * @brief 日志输出组件列表
     * 
     * @details
     * 存储所有已注册的日志输出组件，支持多种输出方式。
     * 每个组件负责将日志消息输出到不同的目标。
     * 
     * @since 1.0.0
     */
    std::vector<std::unique_ptr<ILogOutput>> outputs_;
};
```

### 3.6 模板类注释
模板类需要特殊的Doxygen注释格式：

```cpp
/**
 * @brief 线程安全队列模板类
 * 
 * @tparam T 队列元素类型
 * 
 * @details
 * 提供线程安全的队列操作，支持多生产者-多消费者场景。
 * 使用无锁算法实现，性能优异。
 * 
 * @note 类型T必须支持移动语义
 * @warning 队列大小有限制，超过限制时push操作会失败
 * @since 1.0.0
 * 
 * @example
 * ```cpp
 * ThreadSafeQueue<int> queue;
 * queue.push(42);
 * int value;
 * if (queue.pop(value)) {
 *     std::cout << "Popped: " << value << std::endl;
 * }
 * ```
 */
template<typename T>
class ThreadSafeQueue {
    // ... 实现
};
```

### 3.7 命名空间注释
命名空间应该有Doxygen注释：

```cpp
/**
 * @brief 日志系统核心命名空间
 * 
 * @details
 * 包含日志系统的所有核心组件，提供完整的日志记录功能。
 * 支持多种输出方式、异步处理和配置管理。
 * 
 * @since 1.0.0
 */
namespace log_system {

/**
 * @brief 核心组件命名空间
 * 
 * @details
 * 包含日志系统的核心组件，如日志管理器、消息队列等。
 * 
 * @since 1.0.0
 */
namespace core { }

/**
 * @brief 工具函数命名空间
 * 
 * @details
 * 包含各种工具函数，如时间格式化、字符串处理等。
 * 
 * @since 1.0.0
 */
namespace utils { }

} // namespace log_system
```

### 3.8 内联注释
复杂逻辑需要添加内联注释：

```cpp
// 检查队列是否已满，如果满了则等待
while (messageQueue_->getSize() >= maxQueueSize_) {
    // 等待消费者处理一些消息
    std::this_thread::sleep_for(std::chrono::milliseconds(1));
    
    // 如果等待时间过长，记录警告
    if (++waitCount > MAX_WAIT_COUNT) {
        // TODO: 考虑实现背压机制
        break;
    }
}
```

### 3.9 Doxygen标签使用规范

#### 3.9.1 必需标签
以下标签在所有注释中都必须使用：
- `@brief`: 简短描述（一行）
- `@details`: 详细描述（多行）
- `@param[in/out/inout]`: 参数说明
- `@return`: 返回值说明
- `@since`: 版本信息

#### 3.9.2 可选标签
根据具体情况使用：
- `@note`: 重要说明
- `@warning`: 警告信息
- `@pre`: 前置条件
- `@post`: 后置条件
- `@throws`: 异常说明
- `@see`: 相关引用
- `@example`: 使用示例
- `@tparam`: 模板参数（模板类专用）

#### 3.9.3 特殊注释
- `///<`: 行尾注释，用于简单说明
- `//!`: 行尾注释的另一种形式
- `/*!`: 块注释的开始

### 3.10 Doxygen配置文件
项目根目录必须包含`Doxyfile`配置文件：

```bash
# 基本配置
PROJECT_NAME           = "异步日志系统"
PROJECT_NUMBER         = 1.0.0
PROJECT_BRIEF          = "高性能异步日志系统"
OUTPUT_DIRECTORY       = docs/api

# 输入配置
INPUT                  = include src
FILE_PATTERNS          = *.h *.cpp *.hpp
RECURSIVE              = YES

# 输出配置
GENERATE_HTML          = YES
GENERATE_LATEX         = NO
GENERATE_MAN           = NO

# 提取配置
EXTRACT_ALL            = YES
EXTRACT_PRIVATE        = YES
EXTRACT_STATIC         = YES

# 图表配置
HAVE_DOT               = YES
UML_LOOK               = YES
CALL_GRAPH             = YES
CALLER_GRAPH           = YES
```

## 4. 异常和错误处理规范

### 4.1 异常使用策略
- **何时抛异常**：
  - 库边界和公共API：抛异常处理不可恢复的错误
  - 内部循环/高性能路径：返回错误码
- **异常安全等级**：
  - `basic guarantee`：基本保证，对象状态一致
  - `strong guarantee`：强保证，操作要么成功要么回滚
  - `no-throw guarantee`：不抛异常保证
- **noexcept使用**：析构函数应当`noexcept`

```cpp
/**
 * @brief 日志系统异常类
 * 
 * @details 提供不同级别的异常安全保证
 * @throws 无（析构函数不抛异常）
 */
class LogSystemException : public std::exception {
private:
    std::string message_;
    
public:
    explicit LogSystemException(const std::string& message)
        : message_(message) {}
    
    const char* what() const noexcept override {
        return message_.c_str();
    }
    
    // 析构函数不抛异常
    ~LogSystemException() noexcept = default;
};

// 使用示例
void LogManager::addOutput(std::unique_ptr<ILogOutput> output) {
    if (!output) {
        throw LogSystemException("Output cannot be null");
    }
    
    try {
        outputs_.push_back(std::move(output));
    } catch (const std::exception& e) {
        throw LogSystemException("Failed to add output: " + std::string(e.what()));
    }
}
```



### 4.2 错误码
- 对于可恢复的错误，使用错误码
- 定义清晰的错误码枚举
- 提供错误码到错误信息的映射

```cpp
/**
 * @brief 操作结果枚举
 */
enum class Result {
    SUCCESS = 0,
    INVALID_PARAMETER = 1,
    FILE_NOT_FOUND = 2,
    PERMISSION_DENIED = 3,
    OUT_OF_MEMORY = 4,
    SYSTEM_ERROR = 5
};

/**
 * @brief 获取错误描述
 */
std::string getErrorDescription(Result result) {
    static const std::unordered_map<Result, std::string> descriptions = {
        {Result::SUCCESS, "操作成功"},
        {Result::INVALID_PARAMETER, "无效参数"},
        {Result::FILE_NOT_FOUND, "文件未找到"},
        {Result::PERMISSION_DENIED, "权限不足"},
        {Result::OUT_OF_MEMORY, "内存不足"},
        {Result::SYSTEM_ERROR, "系统错误"}
    };
    
    auto it = descriptions.find(result);
    return (it != descriptions.end()) ? it->second : "未知错误";
}
```

## 5. 并发和线程安全规范

### 5.1 线程安全设计指南
- **锁的粒度**：锁的粒度要尽可能小，避免长时间持有锁
- **原子变量**：简单操作使用`std::atomic`，复杂操作使用锁
- **条件变量**：使用`std::condition_variable`进行线程同步
- **避免死锁**：
  - 固定锁的获取顺序
  - 使用`try_lock`避免长时间等待
  - 避免在持有锁期间进行阻塞操作

```cpp
/**
 * @brief 线程安全的日志队列
 * 
 * @details 使用无锁算法实现，支持多生产者-多消费者
 * @threadsafe 该类是线程安全的
 */
template<typename T>
class ThreadSafeQueue {
private:
    mutable std::mutex mutex_;
    std::condition_variable notEmpty_;
    std::queue<T> queue_;
    
public:
    /**
     * @brief 添加元素到队列
     * @threadsafe 线程安全
     */
    void push(T value) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            queue_.push(std::move(value));
        }
        notEmpty_.notify_one();  // 通知等待的消费者
    }
    
    /**
     * @brief 从队列取出元素
     * @threadsafe 线程安全
     */
    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        notEmpty_.wait(lock, [this] { return !queue_.empty(); });
        
        if (!queue_.empty()) {
            value = std::move(queue_.front());
            queue_.pop();
            return true;
        }
        return false;
    }
};
```

### 5.2 线程注解规范
- 在注释中使用`@threadsafe`标注线程安全的函数
- 使用`@not_threadsafe`标注非线程安全的函数
- 考虑使用clang Thread Safety Analysis进行静态分析

## 6. 性能规范

### 6.1 内存管理
- 避免频繁的内存分配和释放
- 使用对象池管理频繁创建的对象
- 合理使用移动语义

```cpp
// 正确示例：使用移动语义
void LogManager::processMessage(LogMessage&& msg) {
    // 移动构造，避免拷贝
    auto processedMsg = LogMessage(std::move(msg));
    // ... 处理逻辑
}

// 错误示例：不必要的拷贝
void LogManager::processMessage(const LogMessage& msg) {
    LogMessage processedMsg = msg;  // 不必要的拷贝
    // ... 处理逻辑
}
```

### 6.2 算法优化
- 选择合适的容器和算法
- 避免在循环中进行不必要的计算
- 使用引用避免拷贝

```cpp
// 正确示例
void LogManager::notifyAll(const LogMessage& msg) {
    for (const auto& output : outputs_) {
        output->write(msg);  // 传递引用
    }
}

// 错误示例
void LogManager::notifyAll(const LogMessage& msg) {
    for (auto output : outputs_) {  // 不必要的拷贝
        output->write(msg);
    }
}
```

## 7. 构建和CI/CD规范

### 7.1 CMake最佳实践
- **out-of-source构建**：构建目录与源码目录分离
- **精确依赖管理**：使用`INTERFACE`/`PUBLIC`/`PRIVATE`精确表明依赖关系
- **目标配置**：使用`target_include_directories`和`target_link_libraries`

```cmake
# 正确示例
cmake_minimum_required(VERSION 3.16)
project(AsyncLogSystem VERSION 1.0.0)

# 设置C++标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 创建库目标
add_library(log_system INTERFACE)

# 设置包含目录（INTERFACE表示依赖者需要）
target_include_directories(log_system INTERFACE
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

# 创建可执行文件
add_executable(log_demo src/main.cpp)
target_link_libraries(log_demo PRIVATE log_system)

# 测试配置
enable_testing()
add_subdirectory(tests)
```

### 7.2 CI/CD必过项
- **代码格式化**：`clang-format --dry-run`
- **静态分析**：`clang-tidy`、`cppcheck`
- **单元测试**：所有测试必须通过
- **覆盖率门禁**：关键模块90%，普通模块70%
- **Sanitizers**：ASAN/UBSAN/TSan可选构建

```yaml
# GitHub Actions示例
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup CMake
      uses: jwlawson/actions-setup-cmake@v1.2
    
    - name: Configure
      run: cmake -B build -S .
    
    - name: Build
      run: cmake --build build
    
    - name: Format Check
      run: |
        find . -name '*.cpp' -o -name '*.hpp' | xargs clang-format --dry-run --Werror
    
    - name: Static Analysis
      run: |
        clang-tidy --list-checks
        cppcheck --enable=all --error-exitcode=1 .
    
    - name: Test
      run: |
        cd build && ctest --output-on-failure
    
    - name: Coverage
      run: |
        cd build && make coverage
        # 上传覆盖率报告
```

## 8. 测试规范

### 8.1 单元测试
- 每个公共接口都要有对应的单元测试
- 测试覆盖率不低于80%
- 使用Google Test框架

```cpp
// 测试示例
TEST(LogManagerTest, SingletonPattern) {
    auto& instance1 = LogManager::getInstance();
    auto& instance2 = LogManager::getInstance();
    
    EXPECT_EQ(&instance1, &instance2);
}

TEST(LogManagerTest, AddOutput) {
    auto& logger = LogManager::getInstance();
    auto output = std::make_unique<ConsoleOutput>();
    
    EXPECT_NO_THROW(logger.addOutput(std::move(output)));
}
```

### 8.2 集成测试
- 测试组件间的协作
- 测试异常情况下的系统行为
- 测试性能指标

## 9. 代码格式化和自动化工具规范

### 9.1 代码格式化
- 使用`.clang-format`文件统一代码风格
- 在CI中执行`clang-format --dry-run`检查
- 推荐使用LLVM或Google风格，或自定义风格

```yaml
# .clang-format示例
BasedOnStyle: LLVM
IndentWidth: 4
TabWidth: 4
UseTab: Never
ColumnLimit: 120
AccessModifierOffset: -4
NamespaceIndentation: None
AllowShortIfStatementsOnASingleLine: false
AllowShortLoopsOnASingleLine: false
AllowShortFunctionsOnASingleLine: Empty
PointerAlignment: Left
ReferenceAlignment: Left
SpaceAfterTemplateKeyword: true
SpaceBeforeParens: ControlStatements
SpaceInEmptyParentheses: false
SpacesInAngles: false
SpacesInContainerLiterals: false
SpacesInCStyleCastParentheses: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
Standard: Cpp11
UseTab: Never
```

### 9.2 静态分析工具
- **clang-tidy**：启用所有相关检查
- **cppcheck**：静态代码分析
- 在CI中阻断不通过的提交

```bash
# clang-tidy配置示例
# .clang-tidy
Checks: '*,readability-*,performance-*,modernize-*,bugprone-*'
WarningsAsErrors: 'readability-*,performance-*,modernize-*,bugprone-*'
HeaderFilterRegex: '.*'
AnalyzeTemporaryDtors: true
FormatStyle: file
```

### 9.3 Pre-commit Hooks
- 使用pre-commit hooks自动检查代码质量
- 在提交前自动格式化代码
- 检查代码风格和静态分析结果

```yaml
# .pre-commit-config.yaml示例
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
  
  - repo: https://github.com/psf/black
    rev: 23.3.0
    hooks:
      - id: black
  
  - repo: local
    hooks:
      - id: clang-format
        name: clang-format
        entry: clang-format -i
        language: system
        types: [c++, c]
        files: \.(cpp|hpp|c|h)$
```

## 10. 文档规范

### 10.1 文档分类

#### 10.1.1 技术文档
- **项目说明**: 项目简介、需求说明、技术栈、技术难点、技术指标
- **架构文档**: 系统整体架构、组件关系、项目目录
- **设计文档**: 具体模块的设计思路和实现方案
- **开发计划**: 具体到类的项目开发计划（以最小可运行产物 → 增量扩展 → 性能/可维护性增强为原则）
- **API文档**: 详细的接口说明和使用方法
- **部署文档**: 环境配置和部署步骤

#### 10.1.2 用户文档
- **用户手册**: 最终用户的使用指南
- **快速开始**: 快速上手教程
- **常见问题**: FAQ和故障排除

### 10.2 API文档规范

#### 10.2.1 文档生成工具
- 使用 **Doxygen** 自动生成API文档
- 配置Doxygen模板，确保文档风格统一
- 集成到CI/CD流程，自动更新文档

#### 10.2.2 注释要求
- 每个公共类、函数、枚举都必须有详细注释
- 使用标准的Doxygen标签：`@brief`、`@param`、`@return`、`@note`、`@warning`、`@example`
- 注释内容要准确、完整、易懂

```cpp
/**
 * @brief 日志消息类
 * 
 * 封装单条日志消息的所有信息，包括级别、内容、时间戳等。
 * 该类是不可变的，一旦创建就不能修改。
 * 
 * @example
 * ```cpp
 * LogMessage msg(LogLevel::INFO, "系统启动成功");
 * std::cout << msg.toString() << std::endl;
 * ```
 */
class LogMessage {
public:
    /**
     * @brief 构造函数
     * @param level 日志级别
     * @param content 日志内容
     * @param timestamp 时间戳（可选，默认使用当前时间）
     * @param source 日志来源（可选）
     * 
     * @note 如果timestamp为0，将自动使用当前系统时间
     * @warning content不能为空字符串
     */
    LogMessage(LogLevel level, 
               const std::string& content,
               uint64_t timestamp = 0,
               const std::string& source = "");
    
    /**
     * @brief 获取日志级别
     * @return 日志级别枚举值
     */
    LogLevel getLevel() const;
    
    /**
     * @brief 获取日志内容
     * @return 日志内容字符串的常量引用
     */
    const std::string& getContent() const;
};
```

#### 10.2.3 示例代码
- 每个重要的API都要提供完整的使用示例
- 示例代码要简洁、清晰、可运行
- 包含常见使用场景和边界情况

### 10.3 设计文档规范

#### 10.3.1 文档结构
每个设计文档应包含以下部分：

```markdown
# 模块名称设计文档

## 1. 概述
- 模块的职责和目标
- 解决的问题
- 设计原则

## 2. 架构设计
- 整体架构图
- 组件关系
- 数据流

## 3. 详细设计
- 类设计
- 接口设计
- 算法设计

## 4. 设计决策
- 关键决策点
- 备选方案分析
- 决策理由

## 5. 性能考虑
- 性能目标
- 优化策略
- 测试结果

## 6. 测试策略
- 测试方法
- 测试用例
- 覆盖率要求
```

#### 10.3.2 设计决策记录
- 记录重要的设计决策和选择理由
- 说明设计模式的选用原因
- 记录性能测试结果和优化效果
- 记录已知问题和解决方案

#### 10.3.3 架构图规范
- 使用标准的UML图表示法
- 类图、时序图、组件图等
- 图形要清晰、简洁、易于理解
- 提供图例说明

### 10.4 文档维护规范

#### 10.4.1 更新频率
- **API文档**: 每次接口变更后立即更新
- **设计文档**: 设计变更后及时更新
- **用户文档**: 功能发布后同步更新
- **开发文档**: 定期检查和更新

#### 10.4.2 版本控制
- 文档与代码同步版本控制
- 使用语义化版本号
- 记录文档变更历史
- 支持文档回滚

#### 10.4.3 质量检查
- 定期检查文档的准确性和完整性
- 验证示例代码的可运行性
- 检查链接的有效性
- 收集用户反馈并改进

### 10.5 文档工具和流程

#### 10.5.1 推荐工具
- **文档生成**: Doxygen、Sphinx
- **图表绘制**: PlantUML、Draw.io、Visio
- **版本控制**: Git、GitHub Pages
- **协作编辑**: Confluence、Notion

#### 10.5.2 工作流程
1. **文档规划**: 确定文档范围和结构
2. **内容编写**: 按照规范编写文档内容
3. **同行评审**: 技术评审和内容审核
4. **发布部署**: 部署到文档站点
5. **持续维护**: 定期更新和维护

#### 10.5.3 自动化
- 集成到CI/CD流程
- 自动生成API文档
- 自动检查文档链接
- 自动部署文档站点

## 11. 版本控制规范

### 11.1 提交信息
- 使用清晰的提交信息
- 遵循约定式提交规范

```bash
# 正确示例
feat: 添加文件输出装饰器支持
fix: 修复内存泄漏问题
docs: 更新API文档
test: 添加单元测试用例
refactor: 重构日志格式化逻辑

# 错误示例
update
fix bug
add feature
```

### 11.2 分支管理
- 主分支：`main`或`master`
- 开发分支：`develop`
- 功能分支：`feature/功能名`
- 修复分支：`hotfix/问题描述`
- 发布分支：`release/版本号`

## 12. 代码审查规范

### 12.1 审查要点
- **代码风格**：是否符合clang-format规范
- **静态分析**：clang-tidy和cppcheck是否通过
- **性能问题**：是否有潜在的性能瓶颈
- **错误处理**：异常安全和错误处理是否完善
- **测试覆盖**：单元测试覆盖率是否达标
- **文档完整性**：Doxygen注释是否完整
- **现代C++**：是否使用了现代C++特性

### 12.2 审查流程
1. **代码提交**：开发者提交代码到功能分支
2. **自动检查**：CI自动执行格式检查、静态分析、编译检查
3. **代码审查**：审查员进行代码审查，重点关注设计、性能和安全性
4. **问题修复**：开发者根据反馈修改代码
5. **重新审查**：修改后重新审查（如需要）
6. **合并代码**：审查通过后合并到目标分支

### 12.3 审查清单
- [ ] 功能概述清晰
- [ ] 测试覆盖充分
- [ ] 性能影响评估
- [ ] 向后兼容性检查
- [ ] 变更风险评估
- [ ] 文档更新完整
